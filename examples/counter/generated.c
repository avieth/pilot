/* What follows was generated by pilot at revision
 *
 *   f9caa5de1d23e301acef2cf1d8bd768b1336255b
 *
 * from this expression
 *
 *   counter
 *     :: Expr Point.ExprF sval sf Point.UInt32
 *     -> StreamExpr cval cf sval sf val f ('Stream 'Z Point.UInt32)
 *     -> StreamExpr cval cf sval sf val f ('Stream 'Z Point.UInt32)
 *   counter initial modulus = Stream.shift auto auto $ Stream.memory auto auto inits $ \self ->
 *     unlit $ Stream.liftF autoArgs auto auto incrModulo `at` self `at` modulus
 *
 *     where
 *
 *     inits = VCons initial VNil
 *
 *     incrModulo :: Fun (Expr Point.ExprF sval cf)
 *       (Point.UInt32 :-> Point.UInt32 :-> V Point.UInt32)
 *     incrModulo = fun $ \x -> fun $ \m -> lit $
 *       Point.mod auto (Point.add auto (Point.uint32 1) x) m
 *
 * applied to 0 and 7.
 */

#include <stdint.h>
#include <stdio.h>

static uint32_t memory_array_0[0x2] = {0x0};
static uint8_t memory_index_0 = 0x0;

uint32_t eval() {
  (memory_array_0)[(memory_index_0 + 0x1) % 0x2] = ((0x1) + ((memory_array_0)[(memory_index_0) % 0x2])) % (0x7);
  uint32_t return_value_0_0 = (memory_array_0)[(memory_index_0) % 0x2];
  memory_index_0 = (memory_index_0 + 0x1) % 0x2;
  return return_value_0_0;
}
