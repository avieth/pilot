/* What follows was generated by pilot at revision
 *
 *   577399caaf4908fd9fc640c0e352649b65e84815
 *
 * as the result of
 *
 *   Pilot.Interp.C.writeStreamExpr "generated.c" False Examples.example_19
 *
 * It corresponds roughly to this Haskell
 *
 *   example_19 :: Maybe Int32
 *   example_19 = do
 *     a <- inputA
 *     b <- inputB
 *     c <- inputC
 *     pure $ a + (b + c)
 *
 * where the input* terms come from the "real world"; they appear here as
 * externs.
 * 
 * Here is the Haskell concrete syntax for the expression
 *
 *   example_19 :: StreamExpr cval cf sval sf (C.Stream s) (C.CodeGen s) ('Stream 'Z Unit)
 *   example_19 = Expr $ do
 *     inputA <- special (C.externInput "a" (Point.maybe_t Point.int32_t))
 *     inputB <- special (C.externInput "b" (Point.maybe_t Point.int32_t))
 *     inputC <- special (C.externInput "c" (Point.maybe_t Point.int32_t))
 *     let f = fun $ \mx -> fun $ \my -> fun $ \mz -> lit $
 *               maybe_bind auto auto mx $ \x ->
 *               maybe_bind auto auto my $ \y ->
 *               maybe_bind auto auto mz $ \z -> Point.just auto $
 *                 Point.add auto x (Point.add auto y z)
 *     ret <- expr $ unlit $ Stream.liftF autoArgs auto auto
 *       f `at` value inputA
 *         `at` value inputB
 *         `at` value inputC
 *     () <- special (C.externOutput "x" (value ret))
 *     expr $ Stream.constant auto auto Point.unit
 *
 * It's quite verbose but it can probably be made more succint/readable with
 * some effort.
 */

#include <stdint.h>
#include <stdio.h>

enum sum_0_tag {tag_1 , tag_0};
union sum_0_variant
{ int32_t variant_1;
  void *restrict variant_0;
};
struct sum_0
{ enum sum_0_tag tag;
  union sum_0_variant variant;
};
extern struct sum_0 input_c;
extern struct sum_0 input_b;
extern struct sum_0 input_a;
static struct sum_0 output_x;

void * eval() {
  struct sum_0 scrutinee_0_0 = input_a;
  struct sum_0 result_0_1;
  switch ((scrutinee_0_0).tag) {
    {case tag_1: {struct sum_0 scrutinee_1_0 = input_b;
                  struct sum_0 result_1_1;
                  switch ((scrutinee_1_0).tag) {
                    {case tag_1: {struct sum_0 scrutinee_2_0 = input_c;
                                  struct sum_0 result_2_1;
                                  switch ((scrutinee_2_0).tag) {
                                    {case tag_1: {result_2_1 = (struct sum_0){.tag = tag_1, .variant = {.variant_1 = ((scrutinee_0_0).variant.variant_1) + (((scrutinee_1_0).variant.variant_1) + ((scrutinee_2_0).variant.variant_1))}};
                                                  break;};
                                     case tag_0: {result_2_1 = (struct sum_0){.tag = tag_0, .variant = {.variant_0 = NULL}};
                                                  break;};}
                                  };
                                  result_1_1 = result_2_1;
                                  break;};
                     case tag_0: {result_1_1 = (struct sum_0){.tag = tag_0, .variant = {.variant_0 = NULL}};
                                  break;};}
                  };
                  result_0_1 = result_1_1;
                  break;};
     case tag_0: {result_0_1 = (struct sum_0){.tag = tag_0, .variant = {.variant_0 = NULL}};
                  break;};}
  };
  output_x = result_0_1;
  void *const restrict return_value_0_2 = NULL;
  return return_value_0_2;
}
