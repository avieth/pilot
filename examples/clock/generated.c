/* What follows was generated by pilot at revision
 *
 *   4b0b7bd8836c0235c1aa851e1db7ad6079576ec9
 *
 * from the following expression
 *
 *  clock
 *    :: forall cval cf sval sf val f .
 *       Expr Point.ExprF cval cf Point.UInt32 -- ^ Period
 *    -> Expr Point.ExprF cval cf Point.UInt32 -- ^ Phase
 *    -> StreamExpr cval cf sval sf val f ('Stream 'Z Boolean)
 *  clock period phase = unlit $ Stream.liftF autoArgs auto auto f `at` cnt
 *
 *    where
 *
 *    f :: Fun (Expr Point.ExprF cval cf) (Point.UInt32 :-> V Point.Boolean)
 *    f = fun $ \x -> lit $ cmp auto auto x phase
 *          Point.false -- If LT
 *          Point.true  -- If EQ
 *          Point.false -- If GT
 *
 *    cnt = counter (Point.uint32 0) (Stream.constant auto auto period)
 *
 * applied to a period of 5 and a phase of 1
 *
 * The expression `counter` is the one mentioned in examples/counter
 */

#include <stdint.h>
#include <stdio.h>

enum sum_0_tag {tag_1 , tag_0};
union sum_0_variant
{ void *restrict variant_1;
  void *restrict variant_0;
};
struct sum_0
{ enum sum_0_tag tag;
  union sum_0_variant variant;
};
static uint32_t memory_array_0[0x2] = {0x0};
static uint8_t memory_index_0 = 0x0;

struct sum_0 eval() {
  (memory_array_0)[(memory_index_0 + 0x1) % 0x2] = ((0x1) + ((memory_array_0)[(memory_index_0) % 0x2])) % (0x5);
  struct sum_0 return_value_0_0 = ((memory_array_0)[(memory_index_0) % 0x2]) < (0x1) ? (struct sum_0){.tag = tag_0, .variant = {.variant_0 = NULL}} : ((memory_array_0)[(memory_index_0) % 0x2]) > (0x1) ? (struct sum_0){.tag = tag_0, .variant = {.variant_0 = NULL}} : (struct sum_0){.tag = tag_1, .variant = {.variant_1 = NULL}};
  memory_index_0 = (memory_index_0 + 0x1) % 0x2;
  return return_value_0_0;
}
